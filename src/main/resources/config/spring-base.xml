<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       					   http://www.springframework.org/schema/beans/spring-beans.xsd
       					   http://www.springframework.org/schema/tx
                           http://www.springframework.org/schema/tx/spring-tx-4.3.xsd
                           http://www.springframework.org/schema/util
                           http://www.springframework.org/schema/util/spring-util-4.3.xsd
       					   http://www.springframework.org/schema/context
       					   http://www.springframework.org/schema/context/spring-context.xsd">
    <!-- 引入配置文件 -->
    <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="locations">
            <list>
                <value>classpath:config/jdbc.properties</value>
            </list>
        </property>
    </bean>

    <!-- 数据源 -->
    <bean id="dataSource"
          class="org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy">
        <property name="defaultTransactionIsolation" value="2"/>
        <property name="defaultAutoCommit" value="true"/>
        <property name="targetDataSource">
            <bean class="com.alibaba.druid.pool.DruidDataSource">
                <!-- 数据库驱动 -->
                <property name="driverClassName" value="${jdbc.driver}"/>
                <!-- 数据库地址 -->
                <property name="url" value="${jdbc.url}"/>
                <!-- 数据库用户 -->
                <property name="username" value="${jdbc.username}"/>
                <!-- 数据库密码 -->
                <property name="password" value="${jdbc.password}"/>
                <!-- 连接池可以使用的最大连接数量 -->
                <property name="maxActive" value="${proxool.maxConnCount}"/>
                <!-- 连接池使用的最小连接数量 -->
                <property name="minIdle" value="${proxool.minConnCount}"/>
                <!-- 获取连接时最大等待时间，单位毫秒。
                     配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，
                     如果需要可以通过配置useUnfairLock属性为true使用非公平锁。-->
                <property name="maxWait" value="60000"/>
                <property name="useUnfairLock" value="false"/>
                <!-- 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：
                     监控统计用的filter:stat
                     日志用的filter:log4j
                     防御sql注入的filter:wall-->
                <property name="filters" value="stat"/>
                <!-- 有两个含义：1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。
                               2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 -->
                <property name="timeBetweenEvictionRunsMillis" value="60000"/>
                <!-- 连接保持空闲而不被驱逐的最小时间 -->
                <property name="minEvictableIdleTimeMillis" value="300000"/>
                <!-- 用来检测连接是否有效的sql，要求是一个查询语句，常用select 'x'。
                     如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。-->
                <property name="validationQuery" value="SELECT 'x'"/>
                <!-- 建议配置为true，不影响性能，并且保证安全性。
                     申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。-->
                <property name="testWhileIdle" value="true"/>
                <!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。-->
                <property name="testOnBorrow" value="false"/>
                <!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。-->
                <property name="testOnReturn" value="false"/>
            </bean>
        </property>
    </bean>


    <!--<bean id="dataSource"-->
          <!--class="org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy">-->
        <!--<property name="defaultTransactionIsolation" value="2"/>-->
        <!--<property name="defaultAutoCommit" value="true"/>-->
        <!--<property name="targetDataSource">-->
            <!--<bean class="org.logicalcobwebs.proxool.ProxoolDataSource">-->
                <!--&lt;!&ndash; 数据库驱动 &ndash;&gt;-->
                <!--<property name="driver" value="${jdbc.driver}"/>-->
                <!--&lt;!&ndash; 数据库地址 &ndash;&gt;-->
                <!--<property name="driverUrl" value="${jdbc.url}"/>-->
                <!--&lt;!&ndash; 数据库用户 &ndash;&gt;-->
                <!--<property name="user" value="${jdbc.username}"/>-->
                <!--&lt;!&ndash; 数据库密码 &ndash;&gt;-->
                <!--<property name="password" value="${jdbc.password}"/>-->
                <!--&lt;!&ndash; 连接池可以使用的最大连接数量 &ndash;&gt;-->
                <!--<property name="maximumConnectionCount" value="${proxool.maxConnCount}"/>-->
                <!--&lt;!&ndash; 连接池使用的最小连接数量 &ndash;&gt;-->
                <!--<property name="minimumConnectionCount" value="${proxool.minConnCount}"/>-->
                <!--&lt;!&ndash; for debug  &ndash;&gt;-->
                <!--<property name="maximumActiveTime" value="${proxool.maximumActiveTime}"/>-->
                <!--<property name="houseKeepingSleepTime" value="${proxool.houseKeepingSleepTime}"/>-->
                <!--<property name="houseKeepingTestSql" value="${proxool.houseKeepingTestSql}"/>-->
                <!--<property name="statistics" value="${proxool.statistics}"/>-->
                <!--<property name="simultaneousBuildThrottle" value="${proxool.simultaneousBuildThrottle}"/>-->
                <!--<property name="trace" value="${proxool.trace}"/>-->
            <!--</bean>-->
        <!--</property>-->
    <!--</bean>-->

    <!-- sessionFactory -->
    <bean id="sessionFactory"
          class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
        <property name="hibernateProperties">
            <props>
                <!-- 一个Hibernate Dialect类名允许Hibernate针对特定的关系数据库生成优化的SQL.取值 full.classname.of.Dialect -->
                <prop key="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</prop>
                <!-- 在log和console中打出格式后的SQL 取值 true | false-->
                <prop key="hibernate.format_sql">${hibernate.format_sql}</prop>
                <!-- 输出所有SQL语句到控制台 -->
                <prop key="hibernate.show_sql">${hibernate.show_sql}</prop>
                <!-- 允许Hibernate使用JDBC2的批量更新-->
                <prop key="hibernate.jdbc.batch_size">100</prop>
                <!-- 指定JDBC抓取数量的大小 -->
                <prop key="hibernate.jdbc.fetch_size">50</prop>
                <!-- 为单向关联(一对一, 多对一)的外连接抓取（outer join fetch）树设置最大深度. 值为0意味着将关闭默认的外连接抓取-->
                <prop key="hibernate.max_fetch_depth">3</prop>
                <!-- 指定Hibernate在何时释放JDBC连接.
                     默认情况下,直到Session被显式关闭或被断开连接时,才会释放JDBC连接.
                     对于应用程序服务器的JTA数据源, 你应当使用after_statement, 这样在每次JDBC调用后，都会主动的释放连接.
                     对于非JTA的连接, 使用after_transaction在每个事务结束时释放连接是合理的.
                     auto将为JTA和CMT事务策略选择after_statement, 为JDBC事务策略选择after_transaction.-->
                <prop key="hibernate.connection.release_mode">after_transaction</prop>
                <!-- 以频繁的读操作为代价, 优化二级缓存来最小化写操作. 在Hibernate3中，这个设置对的集群缓存非常有用, 对集群缓存的实现而言，默认是开启的.-->
                <prop key="hibernate.cache.use_minimal_puts">true</prop>
                <!-- 能用来完全禁止使用二级缓存. 对那些在类的映射定义中指定<cache>的类，会默认开启二级缓存.取值 true|false-->
                <prop key="hibernate.cache.use_second_level_cache">true</prop>
                <!-- 允许查询缓存, 个别查询仍然需要被设置为可缓存的.取值 true|false-->
                <prop key="hibernate.cache.use_query_cache">true</prop>
                <!-- 二级缓存的提供类-->
                <prop key="hibernate.cache.region.factory_class">
                    org.hibernate.cache.jcache.internal.JCacheRegionFactory
                </prop>
                <prop key="hibernate.javax.cache.provider">org.ehcache.jsr107.EhcacheCachingProvider</prop>
                <prop key="hibernate.current_session_context_class">
                    org.springframework.orm.hibernate5.SpringSessionContext
                </prop>
                <prop key="hibernate.hbm2ddl.auto">${hibernate.hbm2ddl.auto}</prop>
                <prop key="hibernate.javax.cache.missing_cache_strategy">create</prop>
            </props>
        </property>
        <property name="annotatedClasses">
            <ref bean="annotatedClassesList"/>
        </property>
    </bean>

    <util:list id="annotatedClassesList">
        <value>cn.com.yunyoutianxia.simple.domain.entity.Simple</value>
        <value>cn.com.yunyoutianxia.simple.domain.entity.FirmBase</value>
        <value>cn.com.yunyoutianxia.simple.domain.entity.FirmFlow</value>
        <value>cn.com.yunyoutianxia.simple.domain.entity.FirmWechat</value>
        <value>cn.com.yunyoutianxia.simple.domain.entity.Firm</value>
        <value>cn.com.yunyoutianxia.simple.domain.entity.DivisionBase</value>
        <value>cn.com.yunyoutianxia.simple.domain.entity.DivisionFlow</value>
        <value>cn.com.yunyoutianxia.simple.domain.entity.DivisionWechat</value>
        <value>cn.com.yunyoutianxia.simple.domain.entity.Division</value>
    </util:list>

    <tx:annotation-driven order="100"/>
    <bean id="transactionManager"
          class="org.springframework.orm.hibernate5.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory"/>
        <property name="dataSource" ref="dataSource"/>
        <property name="nestedTransactionAllowed" value="true"/>
    </bean>

    <context:component-scan base-package="cn.com.yunyoutianxia.simple">
        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
        <context:exclude-filter type="annotation"
                                expression="org.springframework.web.bind.annotation.ControllerAdvice"/>
    </context:component-scan>

</beans>